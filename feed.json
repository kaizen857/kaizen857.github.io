{
    "version": "https://jsonfeed.org/version/1",
    "title": "kaizen857のblog",
    "subtitle": "这是一只想摸鱼的菜鸟~",
    "icon": "https://kaizen857.github.io/assets/favicon.ico",
    "description": "懒得写捏~~",
    "home_page_url": "https://kaizen857.github.io",
    "items": [
        {
            "id": "https://kaizen857.github.io/stm32/lvgl/vscode-EIDE%E4%B8%8B%E7%A7%BB%E6%A4%8DLVGL%E5%88%B0stm32/",
            "url": "https://kaizen857.github.io/stm32/lvgl/vscode-EIDE%E4%B8%8B%E7%A7%BB%E6%A4%8DLVGL%E5%88%B0stm32/",
            "title": "vscode EIDE下移植LVGL到stm32",
            "date_published": "2025-04-13T00:55:17.000Z",
            "content_html": "<h2 id=\"说在前头\"><a href=\"#说在前头\" class=\"headerlink\" title=\"说在前头\"></a>说在前头</h2><p>&emsp;&emsp;将所有的源码文件全部添加进工程这行为或许有人觉得会严重的增加目标文件的大小，但实际上并不会增加编译后的目标文件大小，只是会使编译过程稍微久一点。</p>\n<p>&emsp;&emsp;编译阶段编译器会将所有在工程里面的源文件编译成 .o 二进制文件。但在链接阶段，链接器只会将用到的函数对应的  .o  文件链接起来，没有用到的  .o  文件并不会链接进目标文件内，对这方面感到疑惑的可以看去 C&#x2F;C++ 的编译过程。</p>\n<h3 id=\"对于各种工程-（包括非-STM32-的-C-C-工程）\"><a href=\"#对于各种工程-（包括非-STM32-的-C-C-工程）\" class=\"headerlink\" title=\"对于各种工程 （包括非 STM32 的 C&#x2F;C++工程）\"></a>对于各种工程 （包括非 STM32 的 C&#x2F;C++工程）</h3><p>&emsp;&emsp;多余添加源码文件进编译：</p>\n<p>&emsp;&emsp;绝大部分情况下是没问题的，不被调用的函数 链接器 不会使用 那个函数所在的 .o 文件。多余添加源码文件的影响只有增加编译时间、产生多一点的 .o 文件占用电脑硬盘，最终编译出来的目标文件即烧录进 STM32 的那个文件保持不变。</p>\n<p>&emsp;&emsp;极少数情况下，多添加文件进行编译会产生冲突，比如 STM32F429 的 FMC 和 FSMC 源文件，同时只能编译一个，这还可能是 库文件设计者 有意为之。</p>\n<p>&emsp;&emsp;少添加源码文件进编译：</p>\n<p>&emsp;&emsp;必定出问题，找不到头文件、函数未定义、符号未定义 等等。</p>\n<h2 id=\"环境介绍\"><a href=\"#环境介绍\" class=\"headerlink\" title=\"环境介绍\"></a>环境介绍</h2><p>&emsp;&emsp;本人使用的代码编写环境：VScode + stm32cubemx + EIDE + clangd</p>\n<p>&emsp;&emsp;由于实在忍受不了keil那沟槽的编辑器，所以在知道了EIDE能直接导入keil还有cubeIDE的工程之后果断地选择跑回了vscode .jpg</p>\n<p>&emsp;&emsp;顺带一提最近看到有大佬在vscode上整了个支持vivado的插件，也就是说现在你还能在vscode上写 FPGA的代码了。真就一个vscode写全部（</p>\n<h2 id=\"前期准备（默认你各种工具都有了-jpg）\"><a href=\"#前期准备（默认你各种工具都有了-jpg）\" class=\"headerlink\" title=\"前期准备（默认你各种工具都有了.jpg）\"></a>前期准备（默认你各种工具都有了.jpg）</h2><h3 id=\"获取LVGL源码\"><a href=\"#获取LVGL源码\" class=\"headerlink\" title=\"获取LVGL源码\"></a>获取LVGL源码</h3><p>LVGL源码仓库地址：<a href=\"https://github.com/lvgl/lvgl\">https://github.com/lvgl/lvgl</a></p>\n<p>你可以使用git将整个项目clone下来，或者你也可以在右上方点击code然后选Download ZIP把源码下载下来：</p>\n<p><img loading=\"lazy\" data-src=\"/stm32/lvgl/vscode-EIDE%E4%B8%8B%E7%A7%BB%E6%A4%8DLVGL%E5%88%B0stm32/Download_zip.png\" alt=\"Download ZIP\"></p>\n<p>想要不同的版本的话也可以在左上角切分支到不同的Releases版本，或者直接从右侧的Releases内下载不同版本的源码：</p>\n<p><img loading=\"lazy\" data-src=\"/stm32/lvgl/vscode-EIDE%E4%B8%8B%E7%A7%BB%E6%A4%8DLVGL%E5%88%B0stm32/%E5%88%87%E6%8D%A2%E7%89%88%E6%9C%AC.png\" alt=\"切换版本\"></p>\n<h4 id=\"LVGL源码文件夹如下图：\"><a href=\"#LVGL源码文件夹如下图：\" class=\"headerlink\" title=\"LVGL源码文件夹如下图：\"></a>LVGL源码文件夹如下图：</h4><p>不管版本如何变，移植到 STM32 (用 Keil 编译) 时，src 文件夹和 源码根目录 下的 .h 、.c  文件都一概先复制过去。</p>\n<p><img loading=\"lazy\" data-src=\"/stm32/lvgl/vscode-EIDE%E4%B8%8B%E7%A7%BB%E6%A4%8DLVGL%E5%88%B0stm32/LVGL%E6%BA%90%E7%A0%81%E6%96%87%E4%BB%B6.png\" alt=\"LVGL源码文件\"></p>\n<h3 id=\"新建工程\"><a href=\"#新建工程\" class=\"headerlink\" title=\"新建工程\"></a>新建工程</h3><p>这边我们使用cubeMX新建一个STM32的工程</p>\n<p>运行LVGL的最低要求：</p>\n<p><img loading=\"lazy\" data-src=\"/stm32/lvgl/vscode-EIDE%E4%B8%8B%E7%A7%BB%E6%A4%8DLVGL%E5%88%B0stm32/%E6%9C%80%E4%BD%8E%E8%A6%81%E6%B1%82.png\" alt=\"最低要求\"></p>\n<p>&emsp;&emsp;实际如果你跑demo里面的bunchmark的话上面的要求完全不够用（</p>\n<p><img loading=\"lazy\" data-src=\"/stm32/lvgl/vscode-EIDE%E4%B8%8B%E7%A7%BB%E6%A4%8DLVGL%E5%88%B0stm32/bunchmark%E5%8D%A0%E7%94%A8.png\" alt=\"bunchmark\"></p>\n<center>跑bunchmark demo时的实际资源占用</center>\n\n<br>\n<br>\n&emsp;&emsp;我这边使用的mcu是stm32f412rgt6，在cubemx里面选择stm32f412rgt，然后按照自己的需求把外部高速晶振打开，主频拉到最大，使用SPI1，并把SPI1的中断和DMA给打开\n\n<p><img loading=\"lazy\" data-src=\"/stm32/lvgl/vscode-EIDE%E4%B8%8B%E7%A7%BB%E6%A4%8DLVGL%E5%88%B0stm32/%E6%97%B6%E9%92%9F.png\" alt=\"时钟设置\" title=\"时钟设置\"></p>\n<p><img loading=\"lazy\" data-src=\"/stm32/lvgl/vscode-EIDE%E4%B8%8B%E7%A7%BB%E6%A4%8DLVGL%E5%88%B0stm32/SPI%E8%AE%BE%E7%BD%AE.png\" alt=\"SPI设置\" title=\"SPI设置\"></p>\n<p><img loading=\"lazy\" data-src=\"/stm32/lvgl/vscode-EIDE%E4%B8%8B%E7%A7%BB%E6%A4%8DLVGL%E5%88%B0stm32/%E4%B8%AD%E6%96%AD.png\" alt=\"中断设置\" title=\"中断设置\"></p>\n<p><img loading=\"lazy\" data-src=\"/stm32/lvgl/vscode-EIDE%E4%B8%8B%E7%A7%BB%E6%A4%8DLVGL%E5%88%B0stm32/DMA.png\" alt=\"DMA设置\" title=\"DMA设置\"></p>\n<p>工程设置界面的工具链选择STM32CubeIDE，在设置完工程之后就可以生成代码了，生成代码时个人推荐选择为不同的外设生成不同的&ensp;.c&#x2F;.h&ensp;文件，这样代码不用一股脑的全扔进main.c里面，能更方便管理。另外注意堆栈要开大一点，默认的堆栈大小跑lvgl可能会炸</p>\n<p><img loading=\"lazy\" data-src=\"/stm32/lvgl/vscode-EIDE%E4%B8%8B%E7%A7%BB%E6%A4%8DLVGL%E5%88%B0stm32/toolchan.png\" alt=\"toolchan\"></p>\n<p><img loading=\"lazy\" data-src=\"/stm32/lvgl/vscode-EIDE%E4%B8%8B%E7%A7%BB%E6%A4%8DLVGL%E5%88%B0stm32/setting.png\" alt=\"setting\"></p>\n<p>(注意我这边选的是copy only necessary library files)</p>\n<p><img loading=\"lazy\" data-src=\"/stm32/lvgl/vscode-EIDE%E4%B8%8B%E7%A7%BB%E6%A4%8DLVGL%E5%88%B0stm32/stack.png\" alt=\"stack\"></p>\n<h2 id=\"代码移植\"><a href=\"#代码移植\" class=\"headerlink\" title=\"代码移植\"></a>代码移植</h2><h3 id=\"移植LVGL\"><a href=\"#移植LVGL\" class=\"headerlink\" title=\"移植LVGL\"></a>移植LVGL</h3><p>工程创建好后我们先在工程根目录创建lvgls文件夹，里面新建两个文件夹，分别为存放lvgl代码的lvgl文件夹和存放自己写的lvgl相关代码的lvgl_app个人文件夹，不过后者本次工程没用到，也可以不创建</p>\n<h4 id=\"项目内lvgl源码文件夹\"><a href=\"#项目内lvgl源码文件夹\" class=\"headerlink\" title=\"项目内lvgl源码文件夹\"></a>项目内lvgl源码文件夹</h4><p><font color=\"orange\">LVGL 源码文件夹</font> 下的 demos、src 文件夹 直接原封不动复制到 lvgl 文件夹下。</p>\n<p><font color=\"orange\">LVGL 源码文件夹</font> 下的 examples 文件夹也可以直接原封不动复制过来，但实际只需要里面的 porting 文件夹，所以自己精简。</p>\n<p><font color=\"orange\">LVGL 源码文件夹</font> 根目录的  .c 、.h  文件一并复制到 lvgl 下。</p>\n<p>搞定上面的步骤后，lvgl 下的 lv_conf_template.h 复制到上一层目录 （即 lvgls 中），并改名为  lv_conf.h 。</p>\n<p><img loading=\"lazy\" data-src=\"/stm32/lvgl/vscode-EIDE%E4%B8%8B%E7%A7%BB%E6%A4%8DLVGL%E5%88%B0stm32/lvgl_files.png\" alt=\"lvgl_files\"></p>\n<p>将 lvgl &#x2F; examples &#x2F; porting 中选中的文件复制到 与 lv_conf.h 文件同一目录下，并把 template 字眼去掉。分别是 （ **disp ）显示 设备和 （**indev ）输入设备的接口。</p>\n<p><img loading=\"lazy\" data-src=\"/stm32/lvgl/vscode-EIDE%E4%B8%8B%E7%A7%BB%E6%A4%8DLVGL%E5%88%B0stm32/lvgl_conf.png\" alt=\"lvgl_conf\"></p>\n<center> 完成后的lvgls文件夹</center>\n\n<h3 id=\"导入项目到EIDE\"><a href=\"#导入项目到EIDE\" class=\"headerlink\" title=\"导入项目到EIDE\"></a>导入项目到EIDE</h3><p>在vscode内打开EIDE，选择导入项目，在中间弹出的选项里面选择Eclipse</p>\n<p><img loading=\"lazy\" data-src=\"/stm32/lvgl/vscode-EIDE%E4%B8%8B%E7%A7%BB%E6%A4%8DLVGL%E5%88%B0stm32/EIDE%E5%AF%BC%E5%85%A5.png\" alt=\"EIDE导入\"></p>\n<p>然后选择你工程根目录下的.cproject</p>\n<p><img loading=\"lazy\" data-src=\"/stm32/lvgl/vscode-EIDE%E4%B8%8B%E7%A7%BB%E6%A4%8DLVGL%E5%88%B0stm32/cproject.png\" alt=\"EIDE导入\"></p>\n<p>导入完成后，切换 VSCode 工作区</p>\n<p><img loading=\"lazy\" data-src=\"/stm32/lvgl/vscode-EIDE%E4%B8%8B%E7%A7%BB%E6%A4%8DLVGL%E5%88%B0stm32/switch.png\" alt=\"切换工作区\"></p>\n<p>由于 Eclipse CDT 和 EIDE 之间的设计差异，EIDE 暂时不能兼容 Eclipse 项目中的一些项目属性和构建设置</p>\n<p>导入完成后，将生成一个 .warning.txt 文件，其中记录了所有不兼容的 Eclipse 项目属性</p>\n<p>您需要根据这些属性的 名称 和 值 的含义修改 EIDE 项目的 构建器选项，直到可以正确编译</p>\n<p><img loading=\"lazy\" data-src=\"/stm32/lvgl/vscode-EIDE%E4%B8%8B%E7%A7%BB%E6%A4%8DLVGL%E5%88%B0stm32/warning.png\" alt=\"warning\"></p>\n<p>正常情况下我们只需要改这几个就差不多了.jpg</p>\n<p><img loading=\"lazy\" data-src=\"/stm32/lvgl/vscode-EIDE%E4%B8%8B%E7%A7%BB%E6%A4%8DLVGL%E5%88%B0stm32/%E9%85%8D%E7%BD%AE.png\" alt=\"配置\"></p>\n<h3 id=\"LVGL文件添加进工程\"><a href=\"#LVGL文件添加进工程\" class=\"headerlink\" title=\"LVGL文件添加进工程\"></a>LVGL文件添加进工程</h3><p>如图.jpg<br><img loading=\"lazy\" data-src=\"/stm32/lvgl/vscode-EIDE%E4%B8%8B%E7%A7%BB%E6%A4%8DLVGL%E5%88%B0stm32/%E9%A1%B9%E7%9B%AE%E8%B5%84%E6%BA%90.png\" alt=\"项目资源\"></p>\n<p><img loading=\"lazy\" data-src=\"/stm32/lvgl/vscode-EIDE%E4%B8%8B%E7%A7%BB%E6%A4%8DLVGL%E5%88%B0stm32/%E9%A1%B9%E7%9B%AE%E5%B1%9E%E6%80%A7.png\" alt=\"项目属性\"></p>\n<p>添加项目属性内的包含目录时的偷懒办法：</p>\n<p><img loading=\"lazy\" data-src=\"/stm32/lvgl/vscode-EIDE%E4%B8%8B%E7%A7%BB%E6%A4%8DLVGL%E5%88%B0stm32/%E5%81%B7%E6%87%92.png\" alt=\"偷懒\"></p>\n<p><img loading=\"lazy\" data-src=\"/stm32/lvgl/vscode-EIDE%E4%B8%8B%E7%A7%BB%E6%A4%8DLVGL%E5%88%B0stm32/%E5%81%B7%E6%87%922.png\" alt=\"偷懒\"></p>\n<p>在这里面你可以直接将包含目录直接复制粘贴进去</p>\n<p>如果你的 lvgl 文件位置和文件夹名称和我的一样，就可以啥也不改，直接黏贴。</p>\n<pre><code class=\"language-yaml\">    - Core/Inc\n    - Drivers/STM32F4xx_HAL_Driver/Inc\n    - Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\n    - Drivers/CMSIS/Device/ST/STM32F4xx/Include\n    - Drivers/CMSIS/Include\n    - lvgls\n    - lvgls/lvgl\n    - lvgls/lvgl/src\n    - lvgls/lvgl/src/core\n    - lvgls/lvgl/src/display\n    - lvgls/lvgl/src/draw\n    - lvgls/lvgl/src/drivers\n    - lvgls/lvgl/src/font\n    - lvgls/lvgl/src/indev\n    - lvgls/lvgl/src/layouts\n    - lvgls/lvgl/src/libs\n    - lvgls/lvgl/src/misc\n    - lvgls/lvgl/src/osal\n    - lvgls/lvgl/src/others\n    - lvgls/lvgl/src/stdlib\n    - lvgls/lvgl/src/themes\n    - lvgls/lvgl/src/tick\n    - lvgls/lvgl/src/widgets\n    - lvgls/lvgl/demos\n    - lvgls/lvgl/demos/benchmark\n    - lvgls/lvgl/demos/widgets\n    - lvgls/lvgl/demos/scroll\n    - lvgls/lvgl/demos/music\n    - c:/ST/STM32CubeCLT_1.16.0/GNU-tools-for-STM32/arm-none-eabi/include\n</code></pre>\n<h3 id=\"LVGL设置\"><a href=\"#LVGL设置\" class=\"headerlink\" title=\"LVGL设置\"></a>LVGL设置</h3><h4 id=\"给LVGL加心跳\"><a href=\"#给LVGL加心跳\" class=\"headerlink\" title=\"给LVGL加心跳\"></a>给LVGL加心跳</h4><p>伴随 HAL_IncTick(); 所在位置，本例是 stm32f4xx_it.c  文件中：</p>\n<pre><code class=\"language-c\"> #include &quot;lv_tick.h&quot;\n\n/****其它******/\n\nvoid SysTick_Handler(void)\n&#123;\n    HAL_IncTick();\n    lv_tick_inc(1);\n&#125;\n</code></pre>\n<p>当然也可以 改为 选择在 定时器中断中 执行<code>lv_tick_inc(1);</code></p>\n<h4 id=\"lv-conf-h中：\"><a href=\"#lv-conf-h中：\" class=\"headerlink\" title=\"lv_conf.h中：\"></a>lv_conf.h中：</h4><p>打开 lv_conf.h ，把 第一个 # if 0  改为 # if 1 从而使能文件，下文简称 使能文件。</p>\n<p>文件中 #define LV_COLOR_DEPTH 16  是配置屏幕色彩深度、我的 LCD 屏幕是 RGB565 , 所以保持无需变更。</p>\n<p>有使能 demo 的宏，本例跑 bunchmark 例子，所以使能：</p>\n<p><img loading=\"lazy\" data-src=\"/stm32/lvgl/vscode-EIDE%E4%B8%8B%E7%A7%BB%E6%A4%8DLVGL%E5%88%B0stm32/demo%E4%BD%BF%E8%83%BD.png\" alt=\"使能\"></p>\n<p>(bunchmark要求将WIDGETS也打开)</p>\n<h4 id=\"lv-port-disp-c-中：\"><a href=\"#lv-port-disp-c-中：\" class=\"headerlink\" title=\"lv_port_disp.c 中：\"></a>lv_port_disp.c 中：</h4><p>使能文件后（注意，对应的头文件也要使能）添加需要的屏幕驱动的头文件，并修改分辨率适配自己的屏幕</p>\n<p><img loading=\"lazy\" data-src=\"/stm32/lvgl/vscode-EIDE%E4%B8%8B%E7%A7%BB%E6%A4%8DLVGL%E5%88%B0stm32/defines.png\" alt=\"defines\"></p>\n<p>修改 <code>lv_port_disp_init()</code> 函数，分配内存，由于我们需要使用DMA来进行数据传输，所以使用模板的Example 2</p>\n<pre><code class=\"language-c\">LV_ATTRIBUTE_MEM_ALIGN\n    static uint8_t __attribute__((section(&quot;.ccmram&quot;))) buf_2_1[MY_DISP_HOR_RES * 10 * BYTE_PER_PIXEL];\n\n    LV_ATTRIBUTE_MEM_ALIGN\n    static uint8_t __attribute__((section(&quot;.ccmram&quot;))) buf_2_2[MY_DISP_HOR_RES * 10 * BYTE_PER_PIXEL];\n    lv_display_set_buffers(disp, buf_2_1, buf_2_2, sizeof(buf_2_1), LV_DISPLAY_RENDER_MODE_PARTIAL);\n</code></pre>\n<p>修改<code>disp_flush()</code>函数，这个函数是LVGL用来向屏幕写数据的函数（刷屏函数），所以需要根据对应的屏幕编写对应的代码，本例的代码如下：</p>\n<pre><code class=\"language-c\">static void disp_flush(lv_display_t *disp_drv, const lv_area_t *area, uint8_t *px_map)\n&#123;\n    if (disp_flush_enabled) &#123;\n\n        uint64_t totalSize = (area-&gt;x2 - area-&gt;x1 + 1) * (area-&gt;y2 - area-&gt;y1 + 1) * BYTE_PER_PIXEL;\n        while (HAL_SPI_GetState(&amp;hspi1) != HAL_SPI_STATE_READY) &#123;&#125;\n        LCD_SetWindows(area-&gt;x1, area-&gt;y1, area-&gt;x2, area-&gt;y2);\n        LCD_CS_CLR;\n        LCD_RS_SET;\n        HAL_SPI_Transmit_DMA(&amp;hspi1, (uint8_t *)(px_map), totalSize);\n    &#125;\n\n    /*IMPORTANT!!!\n     *Inform the graphics library that you are ready with the flushing*/\n    // lv_display_flush_ready(disp_drv);\n&#125;\n\nvoid HAL_SPI_TxCpltCallback(SPI_HandleTypeDef *hspi)\n&#123;\n    LCD_CS_SET;\n    LCD_SetWindows(0, 0, lcddev.width - 1, lcddev.height - 1); \n    lv_display_flush_ready(disp);\n&#125;\n</code></pre>\n<h4 id=\"lv-port-indev-c-中：\"><a href=\"#lv-port-indev-c-中：\" class=\"headerlink\" title=\"lv_port_indev.c 中：\"></a>lv_port_indev.c 中：</h4><p>使能文件、添加必要的 触摸屏头文件如 <code>#include &quot;touch.h&quot;</code></p>\n<p>函数 lv_port_indev_init 中仅保留 touchpad 部分的代码，其他代码可以注释掉或者删除</p>\n<p>然后修改<code>touchpad_read()</code> <code>touchpad_is_pressed()</code> <code>touchpad_get_xy()</code>这三个函数</p>\n<p>本例中我的代码如下：</p>\n<pre><code class=\"language-c\">static void touchpad_read(lv_indev_t *indev_drv, lv_indev_data_t *data)\n&#123;\n    static int32_t last_x = 0;\n    static int32_t last_y = 0;\n\n    /*Save the pressed coordinates and the state*/\n    if (touchpad_is_pressed()) &#123;\n        touchpad_get_xy(&amp;last_x, &amp;last_y);\n        data-&gt;state = LV_INDEV_STATE_PRESSED;\n    &#125; else &#123;\n        data-&gt;state = LV_INDEV_STATE_RELEASED;\n    &#125;\n\n    /*Set the last pressed coordinates*/\n    data-&gt;point.x = last_x;\n    data-&gt;point.y = last_y;\n&#125;\n\n/*Return true is the touchpad is pressed*/\nstatic bool touchpad_is_pressed(void)\n&#123;\n    /*Your code comes here*/\n    return FT6336_Scan();\n    //return false;\n&#125;\n\n/*Get the x and y coordinates if the touchpad is pressed*/\nstatic void touchpad_get_xy(int32_t *x, int32_t *y)\n&#123;\n    /*Your code comes here*/\n\n    (*x) = tp_dev.x[0];\n    (*y) = tp_dev.y[0];\n&#125;\n</code></pre>\n<h4 id=\"main-c中\"><a href=\"#main-c中\" class=\"headerlink\" title=\"main.c中\"></a>main.c中</h4><p>引入头文件：</p>\n<pre><code class=\"language-c\">#include &quot;lvgl.h&quot;\n#include &quot;lv_port_disp.h&quot;\n#include &quot;lv_port_indev.h&quot;\n#include &quot;lv_demos.h&quot;\n#include &quot;lv_demo_benchmark.h&quot;\n#include &quot;touch.h&quot;\n#include &quot;delay.h&quot;\n#include &quot;lcd.h&quot;\n</code></pre>\n<p><code>main()</code>函数</p>\n<pre><code class=\"language-c\">int main(void)\n&#123;\n    HAL_Init();\n    SystemClock_Config();\n    MX_GPIO_Init();\n    MX_DMA_Init();\n    MX_SPI1_Init();\n    delay_init(100);\n    LCD_Init();\n    LCD_direction(1);\n    TP_Init();\n    lv_init();\n    lv_port_disp_init();\n    lv_port_indev_init();\n    lv_demo_benchmark();\n    while (1) &#123;\n        lv_task_handler();\n        HAL_Delay(1);\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"烧录前设置\"><a href=\"#烧录前设置\" class=\"headerlink\" title=\"烧录前设置\"></a>烧录前设置</h3><p>在构建器选项里的c&#x2F;c++编译器选项内，选择c和c++的标准，推荐两个的标准都大于c11 &#x2F; c++11</p>\n<p><img loading=\"lazy\" data-src=\"/stm32/lvgl/vscode-EIDE%E4%B8%8B%E7%A7%BB%E6%A4%8DLVGL%E5%88%B0stm32/%E6%A0%87%E5%87%86%E8%AE%BE%E7%BD%AE.png\" alt=\"标准设置\"></p>\n<p>链接器输出格式为ELF文件</p>\n<p><img loading=\"lazy\" data-src=\"/stm32/lvgl/vscode-EIDE%E4%B8%8B%E7%A7%BB%E6%A4%8DLVGL%E5%88%B0stm32/%E9%93%BE%E6%8E%A5%E5%99%A8.png\" alt=\"链接器\"></p>\n<p>然后编译、烧录、运行、大功告成.jpg</p>\n<h3 id=\"Clangd相关问题\"><a href=\"#Clangd相关问题\" class=\"headerlink\" title=\"Clangd相关问题\"></a>Clangd相关问题</h3><h4 id=\"疯狂报错无法找到头文件\"><a href=\"#疯狂报错无法找到头文件\" class=\"headerlink\" title=\"疯狂报错无法找到头文件\"></a>疯狂报错无法找到头文件</h4><p>在项目里面，clangd对于头文件以及相应函数的查找都是通过<code>compile_commands.json</code>这个文件实现的，这个文件保存了项目中每个源文件的编译命令（包括编译器、选项、头文件路径、宏定义等）。EIDE在每次构建的时候都会在<code>build</code>文件夹下面生成对应的<code>compile_commands.json</code>文件，但clangd默认只搜索工程根目录下是否有这个文件，不会搜索<code>build</code>文件夹。想要clangd找到<code>compile_commands.json</code>文件，有两个办法：</p>\n<p>一是在settings.json里面手动指定<code>compile_commands.json</code>文件的路径</p>\n<p>二是在构建器选项的用户任务里面添加一个构建后任务，把<code>compile_commands.json</code>复制到工程根目录里面</p>\n<p><img loading=\"lazy\" data-src=\"/stm32/lvgl/vscode-EIDE%E4%B8%8B%E7%A7%BB%E6%A4%8DLVGL%E5%88%B0stm32/%E6%9E%84%E5%BB%BA%E5%90%8E%E4%BB%BB%E5%8A%A1.png\" alt=\"构建后任务\"></p>\n<h4 id=\"能识别lvgl等头文件但无法使用标准库的头文件\"><a href=\"#能识别lvgl等头文件但无法使用标准库的头文件\" class=\"headerlink\" title=\"能识别lvgl等头文件但无法使用标准库的头文件\"></a>能识别lvgl等头文件但无法使用标准库的头文件</h4><p>问题原因与上面差不多，只不过是因为<code>compile_commands.json</code>内没包含标准库的文件路径</p>\n<p>解决办法也很简单，在项目属性-&gt;包含目录里面添加使用的标准库的include路径，如：</p>\n<p><img loading=\"lazy\" data-src=\"/stm32/lvgl/vscode-EIDE%E4%B8%8B%E7%A7%BB%E6%A4%8DLVGL%E5%88%B0stm32/std%E8%B7%AF%E5%BE%84.png\" alt=\"std路径\"></p>\n<p><del>用这一套环境比在keil里面写代码舒服多了.jpg</del></p>\n",
            "tags": [
                "stm32",
                "lvgl",
                "lvgl",
                "stm32"
            ]
        },
        {
            "id": "https://kaizen857.github.io/test/%E5%9B%BE%E7%89%87%E6%B5%8B%E8%AF%95/",
            "url": "https://kaizen857.github.io/test/%E5%9B%BE%E7%89%87%E6%B5%8B%E8%AF%95/",
            "title": "图片测试",
            "date_published": "2025-04-11T14:53:58.000Z",
            "content_html": "<h1 id=\"测试图片\"><a href=\"#测试图片\" class=\"headerlink\" title=\"测试图片\"></a>测试图片</h1><p><img loading=\"lazy\" data-src=\"/test/%E5%9B%BE%E7%89%87%E6%B5%8B%E8%AF%95/160_60439088.png\" alt=\"这是测试图片\"></p>\n",
            "tags": [
                "test",
                "test"
            ]
        },
        {
            "id": "https://kaizen857.github.io/test/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/",
            "url": "https://kaizen857.github.io/test/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/",
            "title": "测试文章",
            "date_published": "2025-04-11T06:10:11.000Z",
            "content_html": "<h1 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h1><p>这是博客上的第一篇非自动生成的文章.jpg</p>\n",
            "tags": [
                "test"
            ]
        },
        {
            "id": "https://kaizen857.github.io/test/hello-world/",
            "url": "https://kaizen857.github.io/test/hello-world/",
            "title": "Hello World",
            "date_published": "2025-04-11T05:34:12.679Z",
            "content_html": "<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><pre><code class=\"language-bash\">$ hexo new &quot;My New Post&quot;\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><pre><code class=\"language-bash\">$ hexo server\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><pre><code class=\"language-bash\">$ hexo generate\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><pre><code class=\"language-bash\">$ hexo deploy\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n",
            "tags": []
        }
    ]
}